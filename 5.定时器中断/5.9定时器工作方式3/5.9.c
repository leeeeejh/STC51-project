/*
方式3只能用于T0,定时器T1使用则不计数.
方式3将T0分为两个独立的计数器TL0和TH0,都为8位;
此时T1的中断服务被TH0占用,T0的中断服务被TL0占用,
T1不能再使用中断服务,可以被当作串行口的波特率发生器
*/

#include<reg52.h>
#define uint unsigned int

sbit led1=P1^7;	   //周期为2s
sbit led2=P1^0;	   //周期为1s

void init();	   //中断服务初始化函数

uint num1,num2;

void main()
{
	init();				  //中断服务初始化
	while(1)
	{
		if(3686<=num1)	  //1s	 //重点:使用>=的原因:
		{						 //num1的3683是num2的
			num1=0;				 //倍数,为了防止两个中断
			led1=~led1;			 //同时到达时,对于num1的
		}						 //执行会冲掉num2,使其错
		if(1843<=num2)	  //0.5s //过1843,运行到1844从而
		{						 //出现程序错误.
			num2=0;
			led2=~led2;
		}
	}
}

/*中断服务初始化函数*/
void init()
{
	TMOD=0x03;		//设置定时器0的工作方式3(0000 0011)
	TH0=256-250;	//装初值,271.275us
	TL0=256-250;	//装初值,271.275us
	EA=1;			//开总中断
	ET0=1;			//开定时器0中断
	ET1=1;			//开定时器1中断
	TR0=1;			//启动定时器0
	TR1=1;			//启动定时器0的高8位计数器
}

void TL0_time() interrupt 1			  //TL0占用T0中断
{
	TL0=256-250;		//271.275us,重装初值
	num1++;
}

void TH0_time() interrupt 3
{
	TH0=256-250;		//271.275us,重装初值
	num2++;
}

